### 浏览器的渲染流程

1. 生成DOM（词法分析，语法分析）
2. 计算样式（先生成styleSheets，根据层叠规则和继承规则计算每个DOM节点的样式，并保存在computedStyle中）
3. 布局（过滤掉不显示的元素，生成布局数，计算每个元素的具体位置）
4. 分层（根据布局树对元素进行分层）
5. 绘制（生成一系列的绘制指令，交给合成线程）
6. 合成（合成线程上完成）
   - 将图层进行分块，生成图块
   - 优先选择视口附近的图块，栅格化生成位图（GPU加速）
   - 发送DrawQuad指令给主线程
7. 显示内容。主线程接收到DrawQuad指令，调用操作系统的图形接口将内容显示在屏幕上



### 重排和重绘

​	当我们修改了元素的几何属性，浏览器会触发重新布局和分层以及之后的一系列的阶段，这个过程叫重排。

​	当我们修改了元素的非几何属性，浏览器会跳过布局和分层，直接进入绘制阶段，这个过程叫重绘。

​	重排： **计算属性>布局>分层>绘制>合成>显示**

​	重绘： **计算属性>绘制>合成>显示**   

​	从流程上可以看出来重排比重绘多了布局和分层的阶段，所以效率也会更低，这就是我们应该尽量避免重排的原因。

### 垃圾回收机制

##### 栈中的垃圾回收

当一个函数执行完之后，执行上下文会从栈顶弹出，ESP指针会下移。

##### 堆中的垃圾回收

堆内存会被分成两块，新生代 （存放生存时间短对象） 和老生代（存放生存时间长的对象）。副垃圾回收器负责新生代，主垃圾回收器负责老生代。垃圾回收都要经过如果三个步骤：

1. 标记活动对象和非活动对象
2. 回收非活动对象的内存
3. 内存整理

新生代使用 **Scavenge** 算法将空间对半分成对象区域和空闲区域。标记完成后，副垃圾回收器会将对象区域的活动对象复制到空闲区域并排列，复制完之后两个区域进行角色互换。由于复制操作需要成本，所以新生代设置的很小，而且存的也是存活时间较短的对象。同时采用 **对象晋升策略**，如果经过两次垃圾回收后依然存活的对象，会被移动到老生代中。

老生代中对象的特点是占用空间大，存活时间长。第一种方法是 **标记清除算法**，标记完成后直接回收非活动对象的内存，但是会产生不连续的内存碎片。第二种是 **标记整理算法**，标记完成后活动对象向内存的一端移动（内存整理），然后直接回收活动对象边界以外的内存。

垃圾回收机制会占用主线程，影响JavaScript脚本的执行。**增量标记算** 法将垃圾回收拆分成很多小的任务穿插在 JavaScript 脚本任务之间执行。



### 事件循环



### script 标签的 defer 和 async 属性

defer 是延迟的意思，脚本会并行下载不影响DOM解析，等到 dom 解析完成之后， DOMContentLoaded 之前执行。并且会严格按照标签的顺序执行脚本。

async 是异步的意思，脚本会并行的下载不影响 DOM 的解析，但是一旦下载完成就会执行脚本。不会按照标签的顺序执行，只要下载完成就会执行。

